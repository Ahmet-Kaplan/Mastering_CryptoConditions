Глава 6 - Пример: faucet
Наконец-то мы готовы к первому примеру существуещего СС контракта - faucet (кран). Это очень простой контракт и в первой реализации он столкнулся с очень интересными багами.

Код в файле ~/komodo/src/cc/faucet.cpp наиболее полная документация для него со всеми деталями, поэтому здесь я просто рассмотрю концептуальные проблемы.

В faucet.cpp всего 7 функций, чуть больше 200 строк включая комментарии. Первые три - для валидации, последние четыре - для rpc вызовов.

int64_t IsFaucetvout(struct CCcontract_info *cp,const CTransaction& tx,int32_t v)

bool FaucetExactAmounts(struct CCcontract_info cp,Eval eval,const CTransaction &tx,int32_t minage,uint64_t txfee)

bool FaucetValidate(struct CCcontract_info cp,Eval eval,const CTransaction &tx)

int64_t AddFaucetInputs(struct CCcontract_info *cp,CMutableTransaction &mtx,CPubKey pk,int64_t total,int32_t maxinputs)

std::string FaucetGet(uint64_t txfee)

std::string FaucetFund(uint64_t txfee,int64_t funds)

UniValue FaucetInfo()
Функции реализованные в rpcwallet:

faucetaddress полностью реализована в rpcwallet.cpp
faucetfund вызывает FaucetFund
faucetget вызывает FaucetGet
faucetinfo вызывает FaucetInfo

В данный момент вы возможно не программист, но я надеюсь что вы можете понять приведенную выше последовательность. Пользователь набирает команду в cli вызове, komodo-cli обрабатывает его, вызывая функцию rpc,  которая, в свою очередь, вызывает функцию внутри faucet.cpp

Никакой магии, просто обычное преобразование вызова пользователя из командной строки, запускающего код внутри komodod. Как faucetfund, так и faucetget создают правильно подписанную rawtransaction, которая готова к передаче (трансляции)в сеть, посредством использования стандартного sendrawtransaction rpc. Это не происходит автоматически, чтобы позволить GUI иметь этап подтверждения со всеми деталями перед выполнением невозвратной транзакции на СС контракт.

faucetfund позволяет любому добавлять средства в faucet
faucetget позволяет любому получить 0.1 монету из faucet'а если он не нарушает правила.
И мы приходим к сути. Правила faucet'а. Изначально он был гораздо менее строгим, что позволяло опустошать его медленно, но автоматически, и это не позволяло большинству использовать faucet.

Чтобы сделать возможность "присосаться" к крану гораздо сложнее, было сделано так, что faucetget вовзращает только 0.1 монету (против изначальной 1), то есть теперь в присасывании на 90% меньше смысла. Он также был составлен таким образом, чтобы он должен был иметь свежий адрес с менее чем тремя транзакциями. И наконец, каждый txid должен начинается и заканчиваться с 00! Это крутой трюк, чтобы вынудить использовать драгоценное процессерное время (от 20 до 60 секунд в зависимости от системы) чтобы сгенерировать валидный txid. Вроде PoW майнинга для txid и я ожидаю, что, другие CC контракты будут использовать похожий механизм, если в них будет нужно ограничить предел испольования.

В сочетании, стало достаточно сложно получить 0.1 монеты, проблема протечки крана была решена. Может показаться что не проблема просто поменять адрес чтобы получить еще 0.1 монеты, однако вещи устроены так, что вам нужно запустить komodod -pubkey=<ваш pubkey> чтобы изменить активный для ноды pubkey. Это означает, что для изменения используемого pubkey необходимо перезапустить komodod, а это создает много проблем для любой автоматизации, пытающейся это сделать. В сочетании с необходимостью POW, ваши усилия по истощению крана могут окупиться только тогда, когда 0.1 монеты действительно стоят неплохо. В этом случае PoW требования могут быть увеличены, а количество монет уменьшено, вероятно в CC контракте faucet2, поскольку я не ожидаю, что потребуется множество таких вариаций.
