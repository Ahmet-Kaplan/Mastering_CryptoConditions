Глава 4 - rpc расширения CC
В настоящее время CC контракты нужно интегрировать на уровне источников. Это ограничивает круг тех, кто может создавать и добавлять новые СС контракты, что с одной стороны хорошо, но в конечном итоге будет слишком строгим ограничением. В главе о привязке во время выполнения будет затронуто как выйти за ограничение привязки к исходникам, но существует и другой ключвой интерфейсный уровень - RPC.

По соглашению, каждый СС контракт добавляет связанный набор rpc вызовов в komodo-cli. Это не только упрощает создание транзакций СС контрактов, это так же позволит создавать dapps просто через rpc вызовы. Это потребует наличия достаточного количества уже готовых основных СС контрактов. Вместе с тем, как мы обнаруживаем новые юзкейсы которые не могут быть реализованы через rpc, создается новый CC контракт который может это обеспечить (и даже больше) и мощь rpc-уровня увеличивается. Это долгосрочный процесс.

Типичные rpc вызовы которые добавлены <CC>address, <CClist>, <CCinfo> возвращают различные специальные CC адреса, список экземпляров CC контрактов и информацию о каждом отдельном экзепляре СС контракта. Наряду с rpc который создает экземпляр CC и конечно вызовы для запуска экземпляра СС.
Роль rpc вызовов заключается в создании правильно подписанных rawtransactions которые готовы к трансляции в блокчейн. Это позволяет ограничиваться rpc вызовами не только для запуска но и для создания отдельного экземпляра СС контракта. Контракт faucet выделяется в этом, потому что имеет только один экземпляр и некоторые из этих rpc вызовов для него пропущены.

Таким образом нет ОБЯЗАТЕЛЬНЫХ rpc вызовов, есть просто разумное соглашение чтобы следовать для соответствия общей схеме.

Одна вещь которую я забыл описать, это то, как создать специальный СС адрес, и даже если это не проблема rpc. Это отчасти зависит от основных функций CC, поэтому я покажу, как это сделать здесь:

const char *FaucetCCaddr = "R9zHrofhRbub7ER77B7NrVch3A63R39GuC";
const char *FaucetNormaladdr = "RKQV4oYs4rvxAWx1J43VnT73rSTVtUeckk";
char FaucetCChexstr[67] = { "03682b255c40d0cde8faee381a1a50bbb89980ff24539cb8518e294d3a63cefe12" };
uint8_t FaucetCCpriv[32] = { 0xd4, 0x4f, 0xf2, 0x31, 0x71, 0x7d, 0x28, 0x02, 0x4b, 0xc7, 0xdd, 0x71, 0xa0, 0x39, 0xc4, 0xbe, 0x1a, 0xfe, 0xeb, 0xc2, 0x46, 0xda, 0x76, 0xf8, 0x07, 0x53, 0x3d, 0x96, 0xb4, 0xca, 0xa0, 0xe9 };
Выше приведены параметры для faucet CC, однако каждый контракт имеет эквивалент в CCcustom.cpp. В нижней части файла находится большой оператор switch, в котором эти значения копируются в структуру данных в памяти для каждого типа CC. Это позволяет всей кодовой базе СС иметь доступ к этим специальным адресам стандартным путем.

Чтобы получить приведенные выше значения, выполните следующие действия:
A. используйте getnewaddress чтобы получить новый адрес и вставьте его в строчку <CC>Normaladdr = "";
B. используйте validateaddress <новый адрес из пункта A> для получения pubkey, который вставьте в строчку <CC>hexstr[67] = "";
C. остановите демон и запустите с параметром -pubkey=<pubkey из пункта B> и сделайте <CC>address rpc вызов. В консоли вы получите вывод hex для privkey, предполагая что if ( 0 ) в Myprivkey() включен (CCutils.cpp)
D. обновите CCaddress и privkey и не забудьте изменить параметр -pubkey=

Первая rpc команда которую нужно добавить - <CC>address и чтобы это сделать, добавьте строчку в rpcserver.h и обновите массив команд в rpcserver.cpp

В файле rpcwallet.cpp вы найдете актуальные rpc функции, найдите одну из <CC>address, скопируйте-вставьте, измените eval код на ваш eval код и кастомизируйте функцию. Ох, и не забудьте добавить запись в eval.h

Теперь вы сделали собственный CC контракт, но он не будет скомпонован, поскольку вам по-прежнему нужно имплементировать его действительные функции. Это будет рассмотрено в следующих главах.
